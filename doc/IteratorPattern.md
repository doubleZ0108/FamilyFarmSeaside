# ***\*3.13.Iterator Pattern迭代器模式\****

## ***\*设计模式简述\****

  在现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，如“数据结构”中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。

  “迭代器模式”能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”。

## ***\*3.13.1 Supply实现API\****

### ***\*3.13.1.1 API描述\****

  我们经常需要去查看仓库中剩余的物品的数量以及使用情况，而且有时候我们会希望仅仅查看消耗品，有时候会希望仅仅查看工具，或者会希望去查看那些即将到达使用期限的物品或是即将被用完的消耗品……我们有如此之多的对于仓库中物品的查看方式，所以仅仅将遍历方式固定为某一种是不合理的。

  显然的，将这么多遍历方式都实现一遍并写入仓库管理类中是不合理的，这严重违反了单一职责原则，引起代码的冗余和浪费。因此，我们使用迭代器模式，使得程序逻辑易于理解，可扩展性增强。

| 函数名        | 作用                                             |
| ------------- | ------------------------------------------------ |
| add()         | 向物品的聚合类中添加某种物品。                   |
| remove()      | 从物品的聚合类中移除某种物品。                   |
| getIterator() | 获取一个根据物品的聚合类创建出来的物品的迭代器。 |
| first()       | 获取第一个合理的元素。                           |
| next()        | 获取下一个合理的元素。                           |
| hasNext()     | 判断是否还有下一个合理的元素。                   |

 

### ***\*3.13.1.2类图\****

### ***\*3.13.1.3流程图\****

### ***\*3.13.1.4时序图\****

