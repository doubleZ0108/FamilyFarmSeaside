# 3.8 Decorator / Wrapper Pattern

## 设计模式简述

装饰模式又名包装模式，它以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。运用该设计模式可以动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。

## 3.8.1 ResidenceDecorator 实现 API

### 3.8.1.1 API 描述

Residence 住宅抽象类有函数 getDescription() 和 getCost()，它们分别返回住宅的简介和造价。

在最初的设计中，我们默认每种住宅都有固定的价格：豪宅 50000 元 / 栋，接待中心 30000 元 / 栋，员工宿舍 20000 元 / 栋。但在后续开发过程中，我们想给住宅添加一些附加功能：红外报警器、监控器和中央空调，而增加这些附加功能会相应地增加住宅的造价。如何设计出一个造价动态改变的住宅类呢？这是个问题。

一种传统的做法是创建若干新的子类，例如带红外报警器的住宅、带监控器的接待中心、同时带中央空调和红外报警器的豪宅等等。但这样做的缺点非常明显。假设我们有三种住宅（豪宅、接待中心和员工宿舍）以及三种附加功能（红外报警器、监控器和中央空调），因住宅的种类和附加功能可以任意排列组合，我们需要创建大量的子类，共计 3 * P(3) = 18 种，这是十分繁琐的。

还有一种传统的做法是给住宅类新增3个布尔类的成员变量，用于表示是否安装红外报警器、是否安装监控器和是否安装中央空调。这种做法仍有缺陷：如果以后又有新的附加功能产生，例如太阳能电池板，那我们修改住宅类的设计，给它添加新的布尔类成员变量，用于表示是否安装太阳能电池板。如果我们以后不再支持某个附加功能，我们还得删掉住宅类的相关布尔变量。这违反了开放封闭原则。

为了解决上述缺陷，我们采用装饰模式。首先设计一个附加功能抽象类（ResidenceDecorator)，其继承自住宅类（Residence）。再设计三个附加功能实体类 （Monitor, InfraredAlert 和 CentralAirCondition），它们继承自ResidenceDecorator。这样附加功能类和三种住宅实体类都同时继承自Residence类（是不是很神奇？）。每一个附加功能类内都有一个指向 Residence 类的指针，并且它们也同样具有 getDescription() 和 getCost() 函数。每当我们想要给Residence对象新增某个附加功能时，就创建这个附加功能类并让其成员指针指向Residence对象。这种添加附加功能的操作被称作“装饰”，而附加功能被称作装饰器decorator，原本的三种住宅被称作decorated。

一个decorated在经过各种decorator的装饰后，它们会呈链表状。链表的尾节点为decorated，而其余节点都为decorator。前一个节点的 getDescription() 函数会打印出自己的描述并调用后一个节点的 getDescription() 函数，前一个节点的 getCost() 函数会调用后一个节点的 getCost() 函数并将其返回值与自己的价钱相加。故每当我们想知道被装饰的住宅的简介和总造价时，可以迭代地调用这个链表中每个节点地 getDescription() 和 getCost()。

运用装饰模式，我们的程序变得易于扩展，且满足开放封闭原则。每当我们需要给系统新增一种附加功能时，只需要新增一个附加功能实体类，而无需改变住宅实体类本身。

| 函数名                                                       | 作用                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Dormitory(), ReceptionCenter(), Villa()                      | 三个住宅实体类的构造函数。                                   |
| Monitor(Residence r), InfraredAlert(Residence r), CentralAirCondition(Residence r) | 三个附加功能实体类的构造函数，在调用过程中会将被其装饰的 Residence 对象传给他的成员指针 residence。 |
| double getCost()                                             | 返回住宅的总造价（它可能被装饰也可能未被装饰）               |
| String getDescription()                                      | 返回住宅的描述                                               |

### 3.8.1.2 类图

![Decorator.png](https://github.com/doubleZ0108/FamilyFarmSeaside/blob/CodeGroup/diagram/codeGroup/Decorator.png?raw=true)

### 3.8.1.3 流程图



### 3.8.1.4 时序图





